#include "mcdevtool/addon.h"
#include "mcdevtool/utils.h"
#include <fstream>
#include <iterator>
#include <algorithm>
#include <nlohmann/json.hpp>

namespace MCDevTool::Addon {
    namespace fs = std::filesystem;
    using json   = nlohmann::json;

    // 根据JSON内容解析pack信息
    void parseJsonPackInfo(std::string_view jsonContent, PackInfo& out) {
        auto manifestJson = json::parse(jsonContent, nullptr, false, true);
        if (manifestJson.is_discarded()) {
            // 解析失败
            return;
        }
        auto header = manifestJson.value("header", json::object());
        out.name    = header.value("name", "");
        out.uuid    = header.value("uuid", "");
        // 对于版本号 通常是[]数组 此处保存为字符串避免引入额外的类型依赖
        out.version  = header.value("version", json::array()).dump();
        auto modules = manifestJson.value("modules", json::array());
        // 包类型判定依据需要通过遍历modules数组匹配
        for (const auto& module : modules) {
            auto typeStr = module.value("type", "");
            if (typeStr == "data") {
                out.type = PackType::BEHAVIOR;
                break;
            } else if (typeStr == "resources") {
                out.type = PackType::RESOURCE;
                break;
            }
        }
    }

    // 根据路径解析pack
    void _parsePackInfo(const fs::path& packPath, PackInfo& out) {
        auto manifestPath = packPath / "manifest.json";

        if (!fs::is_directory(packPath) || !fs::is_regular_file(manifestPath)) {
            // 无效的路径/结构
            return;
        }
        // 解析JSON
        std::ifstream manifestFile(manifestPath, std::ios::binary);
        std::string   content((std::istreambuf_iterator<char>(manifestFile)), std::istreambuf_iterator<char>());
        manifestFile.close();
        parseJsonPackInfo(content, out);
        if (out) {
            // 设置路径
            out.path = packPath;
        }
    }

    // 根据路径解析pack
    PackInfo parsePackInfo(const fs::path& packPath) {
        PackInfo info;
        _parsePackInfo(packPath, info);
        return info;
    }

    // 根据路径解析网易pack
    NeteasePackInfo parseNeteasePackInfo(const fs::path& packPath) {
        NeteasePackInfo neteaseInfo;
        _parsePackInfo(packPath, neteaseInfo.baseInfo);
        if (!neteaseInfo.baseInfo || neteaseInfo.baseInfo.type != PackType::BEHAVIOR) {
            return neteaseInfo;
        }
        // 官方暂未定义依赖文件 此处代码仅作占位
        auto dependenciesPath = packPath / "dependencies.json";
        if (!fs::is_regular_file(dependenciesPath)) {
            return neteaseInfo;
        }
        return neteaseInfo;
    }

    // 创建空的AddonManifest 返回行为包与资源包的manifest字符串
    std::pair<std::string, std::string>
    createEmptyAddonManifest(const std::string& name, const std::vector<uint32_t>& version) {
        // clang-format off
        json behaviorManifest{
            {"format_version", 2},
            {"header", {
                {"description", "generated by MCDevTool"},
                {"name", name},
                {"uuid", Utils::createRandomUUID()},
                {"version", version},
                {"min_engine_version", {1, 18, 0}},
            }},
            {"modules", {{
                {"description", "generated by MCDevTool"},
                {"type", "data"},
                {"uuid", Utils::createRandomUUID()},
                {"version", version},
            }}},
        };

        json resourceManifest{
            {"format_version", 2},
            {"header", {
                {"description", "generated by MCDevTool"},
                {"name", name},
                {"uuid", Utils::createRandomUUID()},
                {"version", version},
                {"min_engine_version", {1, 18, 0}},
            }},
            {"modules", {{
                {"description", "generated by MCDevTool"},
                {"type", "resources"},
                {"uuid", Utils::createRandomUUID()},
                {"version", version},
            }}},
        };
        // clang-format on

        return {behaviorManifest.dump(4), resourceManifest.dump(4)};
    }
} // namespace MCDevTool::Addon